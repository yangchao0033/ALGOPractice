# åŠ›æ‰£é¢˜åº“ï¼š[ã€Šè…¾è®¯ç²¾é€‰ç»ƒä¹  50 é¢˜ã€‹](https://leetcode-cn.com/problemset/50/) Swift ç‰ˆ

ðŸ“ðŸ¸ðŸ’âš½ï¸ðŸ€ðŸ¥ŽðŸ„â€â™€ï¸ðŸ„ðŸ„â€â™‚ï¸

**æ¯é“é¢˜ç›®éƒ½ç»è¿‡äº²è‡ªç¼–å†™å’Œæµ‹è¯•ï¼Œå°½é‡ä¿è¯æ‰§è¡Œæ•ˆçŽ‡åŒç™¾ + æžç®€ + swiftyï¼Œå¦‚æœ‰ä¸è¶³è¯·å„ä½é“å‹å¤šåŠ æŒ‡æ­£**

------

#### [2. ä¸¤æ•°ç›¸åŠ ](https://leetcode-cn.com/problems/add-two-numbers/)

ç»™å®šä¸¤ä¸ªéžç©ºé“¾è¡¨è¡¨ç¤ºä¸¤ä¸ªéžè´Ÿæ•´æ•°ï¼Œå…¶ä¸­ï¼Œå®ƒä»¬å„è‡ªæŒ‰ç…§é€†åºæ–¹å¼å­˜å‚¨ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨ä¸€ä½æ•°å­—ã€‚å°†ä¸¤ä¸ªæ•°ç›¸åŠ ï¼Œå¹¶ä½¿ç”¨é“¾è¡¨è¿”å›žå®ƒä»¬çš„å’Œï¼ˆåŒæ ·é€†åºï¼‰

> å·®ç‚¹çœ‹æˆäº†ä¸¤æ•°ä¹‹å’ŒðŸ˜…ï¼Œæœ¬é¢˜éš¾åº¦ä¸ºä¸­ç­‰ï¼Œæ²¡æœ‰å•¥æ·å¾„ï¼Œå€ŸåŠ©å“‘èŠ‚ç‚¹è¿›è¡ŒéåŽ†å³å¯

```swift
let dummy = ListNode(-1)
        var cur: ListNode? = dummy
        var node1 = l1
        var node2 = l2
        var carry = false // è®°å½•æ˜¯å¦æœ‰è¿›ä½
        while node1 != nil || node2 != nil || carry { // è¿™é‡Œä½¿ç”¨ä¸‰ä¸ªæ¡ä»¶ï¼Œå°†ä»£ç ç®€åŒ–åˆ°ä¸€ä¸ªå¾ªçŽ¯ä¸­
            var sum = 0
            if let n1 = node1 {
                sum += n1.val
            }
            if let n2 = node2 {
                sum += n2.val
            }
            sum += carry ? 1 : 0
            carry = sum / 10 > 0
            let newNode = ListNode(sum % 10)
            cur?.next = newNode
            cur = cur?.next
            node1 = node1?.next
            node2 = node2?.next
        }
        return dummy.next
```



### [4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

ç»™å®šä¸¤ä¸ªå¤§å°ä¸º m å’Œ n çš„æ­£åºï¼ˆä»Žå°åˆ°å¤§ï¼‰æ•°ç»„ nums1 å’Œ nums2ã€‚è¯·ä½ æ‰¾å‡ºè¿™ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°ï¼Œå¹¶ä¸”è¦æ±‚ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(log(m + n))ã€‚ä½ å¯ä»¥å‡è®¾ nums1 å’Œ nums2 ä¸ä¼šåŒæ—¶ä¸ºç©ºã€‚

> è™½ç„¶æœ‰ä¸¤ä¸ªè§£æ³•ï¼Œä½†è§£æ³•äºŒä¸º hard åž‹é¢˜è§£ï¼Œæ‰€ä»¥é¢è¯•æ—¶å°½é‡ä¿ä¸€äº‰äºŒ

#### è§£æ³•ä¸€ï¼šåˆå¹¶æœ‰åºæ•°ç»„ O(m + n) ï¼ˆä¸Žé¢˜ç›®è¦æ±‚ä¸ç¬¦åˆï¼Œä½†ç®—æ³•è¾ƒä¸ºç®€å•ï¼‰

```swift
class Solution {
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
      var nums1 = nums1
        func helper() {
            // åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
            var l1 = nums1.count - 1
            var l2 = nums2.count - 1
            var l = nums1.count + nums2.count - 1
            nums1.append(contentsOf: [Int](repeating: 0, count: nums2.count))
            while l1 >= 0 && l2 >= 0 {
                if nums1[l1] > nums2[l2] {
                    nums1[l] = nums1[l1]
                    l1 -= 1
                } else {
                    nums1[l] = nums2[l2]
                    l2 -= 1
                }
                l -= 1
            }
            if l2 >= 0 {
                while l2 >= 0 {
                    nums1[l2] = nums2[l2]
                    l2 -= 1
                }
            }
        }
        helper()
        if nums1.isEmpty {
            return -1
        }
        if nums1.count % 2 == 1 {
            return Double(nums1[nums1.count / 2])
        } else {
            return Double(nums1[nums1.count / 2 - 1] + nums1[nums1.count / 2]) / 2
        }
    }
}
```

#### è§£æ³•äºŒï¼šä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ O(log(m + n))

```swift
class Solution {
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
       let count1 = nums1.count, count2 = nums2.count
        let totalCount = count1 + count2
        if totalCount % 2 == 1 {
            let mid = totalCount / 2
            return Double(getKthElement(nums1, nums2, mid + 1))
        } else {
            let mid1 = totalCount / 2 - 1, mid2 = totalCount / 2
            return Double(getKthElement(nums1, nums2, mid1 + 1) + getKthElement(nums1, nums2, mid2 + 1)) / 2
        }
    }
    // èŽ·å–ä¸¤ä¸ªæ•°ç»„ä¸­ç¬¬ K å°çš„æ•°
    func getKthElement(_ nums1: [Int], _ nums2: [Int],_ k: Int) -> Int {
        var k = k
        let count1 = nums1.count, count2 = nums2.count
        var index1 = 0, index2 = 0
        
        while true {
            if index1 == count1 {
                return nums2[index2 + k - 1]
            }
            if index2 == count2 {
                return nums1[index1 + k - 1]
            }
            if k == 1 {
                return min(nums1[index1], nums2[index2])
            }
            let half = k / 2
            let newIndex1 = min(index1 + half, count1) - 1
            let newIndex2 = min(index2 + half, count2) - 1
            let pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2]
            if pivot1 <= pivot2 {
                k -= newIndex1 - index1 + 1
                index1 = newIndex1 + 1
            } else {
                k -= newIndex2 - index2 + 1
                index2 = newIndex2 + 1
            }
        }
    }
}
```





------

### [88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„](https://leetcode-cn.com/problems/merge-sorted-array/)

ç»™ä½ ä¸¤ä¸ªæœ‰åºæ•´æ•°æ•°ç»„ nums1 å’Œ nums2ï¼Œè¯·ä½ å°† nums2 åˆå¹¶åˆ° nums1 ä¸­ï¼Œä½¿ nums1 æˆä¸ºä¸€ä¸ªæœ‰åºæ•°ç»„ã€‚

è¯´æ˜Ž:

åˆå§‹åŒ– nums1 å’Œ nums2 çš„å…ƒç´ æ•°é‡åˆ†åˆ«ä¸º m å’Œ n ã€‚
ä½ å¯ä»¥å‡è®¾ nums1 æœ‰è¶³å¤Ÿçš„ç©ºé—´ï¼ˆç©ºé—´å¤§å°å¤§äºŽæˆ–ç­‰äºŽ m + nï¼‰æ¥ä¿å­˜ nums2 ä¸­çš„å…ƒç´ ã€‚

```swift
func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
        // åŒæŒ‡é’ˆ
        var l1 = m - 1
        var l2 = n - 1
        var l = m + n - 1
        
        while l1 >= 0 && l2 >= 0 {
            if nums1[l1] > nums2[l2] {
                nums1[l] = nums1[l1]
                l1 -= 1
            } else {
                nums1[l] = nums2[l2]
                l2 -= 1
            }
            l -= 1
        }
        if l2 >= 0 {
            nums1.replaceSubrange(0..<l2 + 1, with: nums2[0..<l2 + 1])  // è¿™é‡Œå¯ä»¥æ›¿æ¢ä¸º while å¾ªçŽ¯
            /*
            while l2 >= 0 {
                nums1[l2] = nums2[l2]
                l2 -= 1
            }
             */
        }
    }
```





### [237. åˆ é™¤é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

ç»™å®šä¸€ä¸ª node èŠ‚ç‚¹ï¼Œå°†å…¶åœ¨é“¾è¡¨ä¸­åˆ é™¤ã€‚ï¼ˆæ¯”è¾ƒ trickyï¼Œç›´æŽ¥æ¢ val å¯è¿˜è¡Œï¼Ÿï¼‰

```swift
class Solution {
    func deleteNode(_ node: ListNode?) {
        guard let next = node?.next else { return }
        node?.val = next.val
        node?.next = next.next
    }
}
```

### [104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

æ±‚äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ï¼Œä¹Ÿå°±æ˜¯æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€è¿œè·¯å¾„çš„èŠ‚ç‚¹æ•°ã€‚

> æŽ¨èä½¿ç”¨æ·±åº¦ä¼˜å…ˆï¼Œé€’å½’å³å¯å¿«é€Ÿè§£é¢˜ï¼Œå¹¶ä¸”å¤æ‚åº¦å’Œå¹¿åº¦ä¼˜å…ˆç›¸åŒ

```swift
class Solution {
    func maxDepth(_ root: TreeNode?) -> Int {
        guard let root = root else { return  0 }
        return max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
}
```