# 力扣题库：[《腾讯精选练习 50 题》](https://leetcode-cn.com/problemset/50/) Swift 版

🏓🏸🏒⚽️🏀🥎🏄‍♀️🏄🏄‍♂️

**每道题目都经过亲自编写和测试，尽量保证执行效率双百 + 极简 + swifty，如有不足请各位道友多加指正**

------

#### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给定两个非空链表表示两个非负整数，其中，它们各自按照逆序方式存储，并且每个节点只能存储一位数字。将两个数相加，并使用链表返回它们的和（同样逆序）

> 差点看成了两数之和😅，本题难度为中等，没有啥捷径，借助哑节点进行遍历即可

```swift
let dummy = ListNode(-1)
        var cur: ListNode? = dummy
        var node1 = l1
        var node2 = l2
        var carry = false // 记录是否有进位
        while node1 != nil || node2 != nil || carry { // 这里使用三个条件，将代码简化到一个循环中
            var sum = 0
            if let n1 = node1 {
                sum += n1.val
            }
            if let n2 = node2 {
                sum += n2.val
            }
            sum += carry ? 1 : 0
            carry = sum / 10 > 0
            let newNode = ListNode(sum % 10)
            cur?.next = newNode
            cur = cur?.next
            node1 = node1?.next
            node2 = node2?.next
        }
        return dummy.next
```



### [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。

> 虽然有两个解法，但解法二为 hard 型题解，所以面试时尽量保一争二

#### 解法一：合并有序数组 O(m + n) （与题目要求不符合，但算法较为简单）

```swift
class Solution {
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
      var nums1 = nums1
        func helper() {
            // 合并两个有序数组
            var l1 = nums1.count - 1
            var l2 = nums2.count - 1
            var l = nums1.count + nums2.count - 1
            nums1.append(contentsOf: [Int](repeating: 0, count: nums2.count))
            while l1 >= 0 && l2 >= 0 {
                if nums1[l1] > nums2[l2] {
                    nums1[l] = nums1[l1]
                    l1 -= 1
                } else {
                    nums1[l] = nums2[l2]
                    l2 -= 1
                }
                l -= 1
            }
            if l2 >= 0 {
                while l2 >= 0 {
                    nums1[l2] = nums2[l2]
                    l2 -= 1
                }
            }
        }
        helper()
        if nums1.isEmpty {
            return -1
        }
        if nums1.count % 2 == 1 {
            return Double(nums1[nums1.count / 2])
        } else {
            return Double(nums1[nums1.count / 2 - 1] + nums1[nums1.count / 2]) / 2
        }
    }
}
```

#### 解法二：使用二分查找 O(log(m + n))

```swift
class Solution {
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
       let count1 = nums1.count, count2 = nums2.count
        let totalCount = count1 + count2
        if totalCount % 2 == 1 {
            let mid = totalCount / 2
            return Double(getKthElement(nums1, nums2, mid + 1))
        } else {
            let mid1 = totalCount / 2 - 1, mid2 = totalCount / 2
            return Double(getKthElement(nums1, nums2, mid1 + 1) + getKthElement(nums1, nums2, mid2 + 1)) / 2
        }
    }
    // 获取两个数组中第 K 小的数
    func getKthElement(_ nums1: [Int], _ nums2: [Int],_ k: Int) -> Int {
        var k = k
        let count1 = nums1.count, count2 = nums2.count
        var index1 = 0, index2 = 0
        
        while true {
            if index1 == count1 {
                return nums2[index2 + k - 1]
            }
            if index2 == count2 {
                return nums1[index1 + k - 1]
            }
            if k == 1 {
                return min(nums1[index1], nums2[index2])
            }
            let half = k / 2
            let newIndex1 = min(index1 + half, count1) - 1
            let newIndex2 = min(index2 + half, count2) - 1
            let pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2]
            if pivot1 <= pivot2 {
                k -= newIndex1 - index1 + 1
                index1 = newIndex1 + 1
            } else {
                k -= newIndex2 - index2 + 1
                index2 = newIndex2 + 1
            }
        }
    }
}
```





------

### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

说明:

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

```swift
func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
        // 双指针
        var l1 = m - 1
        var l2 = n - 1
        var l = m + n - 1
        
        while l1 >= 0 && l2 >= 0 {
            if nums1[l1] > nums2[l2] {
                nums1[l] = nums1[l1]
                l1 -= 1
            } else {
                nums1[l] = nums2[l2]
                l2 -= 1
            }
            l -= 1
        }
        if l2 >= 0 {
            nums1.replaceSubrange(0..<l2 + 1, with: nums2[0..<l2 + 1])  // 这里可以替换为 while 循环
            /*
            while l2 >= 0 {
                nums1[l2] = nums2[l2]
                l2 -= 1
            }
             */
        }
    }
```





### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

给定一个 node 节点，将其在链表中删除。（比较 tricky，直接换 val 可还行？）

```swift
class Solution {
    func deleteNode(_ node: ListNode?) {
        guard let next = node?.next else { return }
        node?.val = next.val
        node?.next = next.next
    }
}
```

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

求二叉树的最大深度，也就是根节点到叶子节点的最远路径的节点数。

> 推荐使用深度优先，递归即可快速解题，并且复杂度和广度优先相同

```swift
class Solution {
    func maxDepth(_ root: TreeNode?) -> Int {
        guard let root = root else { return  0 }
        return max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
}
```