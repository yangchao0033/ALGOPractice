# 力扣题库：[《腾讯精选练习 50 题》](https://leetcode-cn.com/problemset/50/) Swift 版

🏓🏸🏒⚽️🏀🥎🏄‍♀️🏄🏄‍♂️

**每道题目都经过亲自编写和测试，尽量保证执行效率双百 + 极简 + swifty，如有不足请各位道友多加指正**

------

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给定两个非空链表表示两个非负整数，其中，它们各自按照逆序方式存储，并且每个节点只能存储一位数字。将两个数相加，并使用链表返回它们的和（同样逆序）

> 差点看成了两数之和😅，本题难度为中等，没有啥捷径，借助哑节点进行遍历即可，注意进位的处理。

```swift
let dummy = ListNode(-1)
        var cur: ListNode? = dummy
        var node1 = l1
        var node2 = l2
        var carry = false // 记录是否有进位
        while node1 != nil || node2 != nil || carry { // 这里使用三个条件，将代码简化到一个循环中
            var sum = 0
            if let n1 = node1 {
                sum += n1.val
            }
            if let n2 = node2 {
                sum += n2.val
            }
            sum += carry ? 1 : 0
            carry = sum / 10 > 0
            let newNode = ListNode(sum % 10)
            cur?.next = newNode
            cur = cur?.next
            node1 = node1?.next
            node2 = node2?.next
        }
        return dummy.next
```



### [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。

> 虽然有两个解法，但解法二为 hard 型题解，所以面试时尽量保一争二

#### 解法一：合并有序数组 O(m + n) （与题目要求不符合，但算法较为简单）

```swift
class Solution {
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
      var nums1 = nums1
        func helper() {
            // 合并两个有序数组
            var l1 = nums1.count - 1
            var l2 = nums2.count - 1
            var l = nums1.count + nums2.count - 1
            nums1.append(contentsOf: [Int](repeating: 0, count: nums2.count))
            while l1 >= 0 && l2 >= 0 {
                if nums1[l1] > nums2[l2] {
                    nums1[l] = nums1[l1]
                    l1 -= 1
                } else {
                    nums1[l] = nums2[l2]
                    l2 -= 1
                }
                l -= 1
            }
            if l2 >= 0 {
                while l2 >= 0 {
                    nums1[l2] = nums2[l2]
                    l2 -= 1
                }
            }
        }
        helper()
        if nums1.isEmpty {
            return -1
        }
        if nums1.count % 2 == 1 {
            return Double(nums1[nums1.count / 2])
        } else {
            return Double(nums1[nums1.count / 2 - 1] + nums1[nums1.count / 2]) / 2
        }
    }
}
```

#### 解法二：使用二分查找 O(log(m + n)) 💪

```swift
class Solution {
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
       let count1 = nums1.count, count2 = nums2.count
        let totalCount = count1 + count2
        if totalCount % 2 == 1 {
            let mid = totalCount / 2
            return Double(getKthElement(nums1, nums2, mid + 1))
        } else {
            let mid1 = totalCount / 2 - 1, mid2 = totalCount / 2
            return Double(getKthElement(nums1, nums2, mid1 + 1) + getKthElement(nums1, nums2, mid2 + 1)) / 2
        }
    }
    // 获取两个数组中第 K 小的数
    func getKthElement(_ nums1: [Int], _ nums2: [Int],_ k: Int) -> Int {
        var k = k
        let count1 = nums1.count, count2 = nums2.count
        var index1 = 0, index2 = 0
        
        while true {
            if index1 == count1 {
                return nums2[index2 + k - 1]
            }
            if index2 == count2 {
                return nums1[index1 + k - 1]
            }
            if k == 1 {
                return min(nums1[index1], nums2[index2])
            }
            let half = k / 2
            let newIndex1 = min(index1 + half, count1) - 1
            let newIndex2 = min(index2 + half, count2) - 1
            let pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2]
            if pivot1 <= pivot2 {
                k -= newIndex1 - index1 + 1
                index1 = newIndex1 + 1
            } else {
                k -= newIndex2 - index2 + 1
                index2 = newIndex2 + 1
            }
        }
    }
}
```

### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

#### 暴力算法 

> Time:O(n^3) Space: O(1)

```swift
func longestPalindrome(_ s: String) -> String {
        // 暴力算法
        let n = s.count
        guard n >= 2 else { return s }
        
        var maxLength = 1
        var begin = 0
        let chars = Array(s)
        // 枚举所有长度严格大于 1 的子串 chars[i..j]
        for i in 0..<n - 1 {
            for j in i + 1..<n {
                if j - i + 1 > maxLength && validHelper(chars, i, j) {
                    maxLength = j - i + 1
                    begin = i
                }
            }
        }
        return String(chars[begin..<(begin + maxLength)])
}

func validHelper(_ arr: [Character], _ i: Int, _ j: Int) -> Bool {
  var i = i
  var j = j
  while i < j {
    if arr[i] != arr[j] {
      return false
    }
    i += 1
    j -= 1
  }
  return true
}
```

#### 动态规划 

> Time: O(n^2) space: O(n^2)

```swift
func longestPalindrome(_ s: String) -> String {
        // 动态规划
        // dp(i, j) = s[i] == s[j] && dp(i + 1, j - 1)
        let n = s.count
        guard n >= 2 else {
            return s
        }
        var maxLength = 1
        var begin = 0
        var dp = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)
        // 对角线都为 true（因为单个字符必定为回文序列）
        for i in 0..<n {
            dp[i][i] = true
        }
        let chars = Array(s)
        for j in 1..<n { // 对角线已经处理，所以列从 1 开始
            for i in 0..<j { // 对角线以下不用管，所以只到 j 就结束了
                if chars[i] != chars[j] {
                    dp[i][j] = false
                } else {
                    dp[i][j] = j - i < 3 || dp[i + 1][j - 1] // 简化为 1 行，等同于下面 5 行
//                    if j - 1 - (i + 1) + 1 < 2 { // 表示 j - 1 到 i + 1 之间没有字符或只有一个字符，则肯定是回文串
//                        dp[i][j] = true
//                    } else {
//                        dp[i][j] = dp[i + 1][j - 1] // 状态转移，更里面的子串会优先计算出回文性质
//                    }
                }
                if dp[i][j] && j - i + 1 > maxLength { // 如果状态正确且长度大于原先的最大长度，则对 begin 和 maxLength 进行更新
                    maxLength = j - i + 1
                    begin = i
                }
            }
        }
        return String(chars[begin..<(begin+maxLength)])
    }
```



### [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转

```swift
	func reverse(_ x: Int) -> Int {
    var x = x
    var res = 0
    while x != 0 {
      let mod = x % 10 // 得出末尾数字
      x /= 10 // 剔除末尾
      res = res * 10 + mod // 逆序求和
    }
    return abs(res) > Int32.max ? 0 : res
  }
```



## [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。在任何情况下，若函数不能进行有效的转换时，请返回 0 。

```swift
	func myAtoi(_ str: String) -> Int {
        let chars = Array(str)
        let n = chars.count
        var idx = 0
        while idx < n && chars[idx] == " " {
            idx += 1 // 去空格
        }
        if idx == n {
            return 0
        }
        // 处理符号
        var sign = 1
        if chars[idx] == "-" {
            sign = -1
            idx += 1
        } else if chars[idx] == "+" {
            idx += 1
        } else if !(chars[idx].isASCII && chars[idx].isWholeNumber) {
            return 0
        }
        var ans = 0
        while idx < n {
            if !(chars[idx].isASCII && chars[idx].isWholeNumber) {
                break
            }
            let digit = chars[idx].wholeNumberValue!
            if ans > (Int(Int32.max) - digit) / 10 {
                return Int(sign > 0 ? Int32.max : Int32.min)
            }
            ans = ans * 10 + digit
            idx += 1
        }
        return ans * sign
    }
```



### [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

```swift
	func isPalindrome(_ x: Int) -> Bool {
        if x < 0 || (x % 10 == 0 && x != 0) {
            return false
        }
        var reverseNumber = 0
        var x = x
        while reverseNumber < x {
            reverseNumber = reverseNumber * 10 + x % 10
            x /= 10
        }
        return reverseNumber == x || x == reverseNumber / 10
    }
```





------

### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

说明:

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

```swift
	func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
        // 双指针
        var l1 = m - 1
        var l2 = n - 1
        var l = m + n - 1
        
        while l1 >= 0 && l2 >= 0 {
            if nums1[l1] > nums2[l2] {
                nums1[l] = nums1[l1]
                l1 -= 1
            } else {
                nums1[l] = nums2[l2]
                l2 -= 1
            }
            l -= 1
        }
        if l2 >= 0 {
            nums1.replaceSubrange(0..<l2 + 1, with: nums2[0..<l2 + 1])  // 这里可以替换为 while 循环
            /*
            while l2 >= 0 {
                nums1[l2] = nums2[l2]
                l2 -= 1
            }
             */
        }
    }
```



### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

给定一个 node 节点，将其在链表中删除。（比较 tricky，直接换 val 可还行？）

```swift
class Solution {
    func deleteNode(_ node: ListNode?) {
        guard let next = node?.next else { return }
        node?.val = next.val
        node?.next = next.next
    }
}
```

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

求二叉树的最大深度，也就是根节点到叶子节点的最远路径的节点数。

> 推荐使用深度优先，递归即可快速解题，并且复杂度和广度优先相同

```swift
class Solution {
    func maxDepth(_ root: TreeNode?) -> Int {
        guard let root = root else { return  0 }
        return max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
}
```