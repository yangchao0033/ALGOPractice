# åŠ›æ‰£é¢˜åº“ï¼š[ã€Šè…¾è®¯ç²¾é€‰ç»ƒä¹  50 é¢˜ã€‹](https://leetcode-cn.com/problemset/50/) Swift ç‰ˆ

ğŸ“ğŸ¸ğŸ’âš½ï¸ğŸ€ğŸ¥ğŸ„â€â™€ï¸ğŸ„ğŸ„â€â™‚ï¸

**æ¯é“é¢˜ç›®éƒ½ç»è¿‡äº²è‡ªç¼–å†™å’Œæµ‹è¯•ï¼Œå°½é‡ä¿è¯æ‰§è¡Œæ•ˆç‡åŒç™¾ + æç®€ + swiftyï¼Œå¦‚æœ‰ä¸è¶³è¯·å„ä½é“å‹å¤šåŠ æŒ‡æ­£**

------

### [2. ä¸¤æ•°ç›¸åŠ ](https://leetcode-cn.com/problems/add-two-numbers/)

ç»™å®šä¸¤ä¸ªéç©ºé“¾è¡¨è¡¨ç¤ºä¸¤ä¸ªéè´Ÿæ•´æ•°ï¼Œå…¶ä¸­ï¼Œå®ƒä»¬å„è‡ªæŒ‰ç…§é€†åºæ–¹å¼å­˜å‚¨ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨ä¸€ä½æ•°å­—ã€‚å°†ä¸¤ä¸ªæ•°ç›¸åŠ ï¼Œå¹¶ä½¿ç”¨é“¾è¡¨è¿”å›å®ƒä»¬çš„å’Œï¼ˆåŒæ ·é€†åºï¼‰

> å·®ç‚¹çœ‹æˆäº†ä¸¤æ•°ä¹‹å’ŒğŸ˜…ï¼Œæœ¬é¢˜éš¾åº¦ä¸ºä¸­ç­‰ï¼Œæ²¡æœ‰å•¥æ·å¾„ï¼Œå€ŸåŠ©å“‘èŠ‚ç‚¹è¿›è¡Œéå†å³å¯ï¼Œæ³¨æ„è¿›ä½çš„å¤„ç†ã€‚

```swift
let dummy = ListNode(-1)
        var cur: ListNode? = dummy
        var node1 = l1
        var node2 = l2
        var carry = false // è®°å½•æ˜¯å¦æœ‰è¿›ä½
        while node1 != nil || node2 != nil || carry { // è¿™é‡Œä½¿ç”¨ä¸‰ä¸ªæ¡ä»¶ï¼Œå°†ä»£ç ç®€åŒ–åˆ°ä¸€ä¸ªå¾ªç¯ä¸­
            var sum = 0
            if let n1 = node1 {
                sum += n1.val
            }
            if let n2 = node2 {
                sum += n2.val
            }
            sum += carry ? 1 : 0
            carry = sum / 10 > 0
            let newNode = ListNode(sum % 10)
            cur?.next = newNode
            cur = cur?.next
            node1 = node1?.next
            node2 = node2?.next
        }
        return dummy.next
```



### [4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

ç»™å®šä¸¤ä¸ªå¤§å°ä¸º m å’Œ n çš„æ­£åºï¼ˆä»å°åˆ°å¤§ï¼‰æ•°ç»„ nums1 å’Œ nums2ã€‚è¯·ä½ æ‰¾å‡ºè¿™ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°ï¼Œå¹¶ä¸”è¦æ±‚ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(log(m + n))ã€‚ä½ å¯ä»¥å‡è®¾ nums1 å’Œ nums2 ä¸ä¼šåŒæ—¶ä¸ºç©ºã€‚

> è™½ç„¶æœ‰ä¸¤ä¸ªè§£æ³•ï¼Œä½†è§£æ³•äºŒä¸º hard å‹é¢˜è§£ï¼Œæ‰€ä»¥é¢è¯•æ—¶å°½é‡ä¿ä¸€äº‰äºŒ

#### è§£æ³•ä¸€ï¼šåˆå¹¶æœ‰åºæ•°ç»„ O(m + n) ï¼ˆä¸é¢˜ç›®è¦æ±‚ä¸ç¬¦åˆï¼Œä½†ç®—æ³•è¾ƒä¸ºç®€å•ï¼‰

```swift
class Solution {
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
      var nums1 = nums1
        func helper() {
            // åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
            var l1 = nums1.count - 1
            var l2 = nums2.count - 1
            var l = nums1.count + nums2.count - 1
            nums1.append(contentsOf: [Int](repeating: 0, count: nums2.count))
            while l1 >= 0 && l2 >= 0 {
                if nums1[l1] > nums2[l2] {
                    nums1[l] = nums1[l1]
                    l1 -= 1
                } else {
                    nums1[l] = nums2[l2]
                    l2 -= 1
                }
                l -= 1
            }
            if l2 >= 0 {
                while l2 >= 0 {
                    nums1[l2] = nums2[l2]
                    l2 -= 1
                }
            }
        }
        helper()
        if nums1.isEmpty {
            return -1
        }
        if nums1.count % 2 == 1 {
            return Double(nums1[nums1.count / 2])
        } else {
            return Double(nums1[nums1.count / 2 - 1] + nums1[nums1.count / 2]) / 2
        }
    }
}
```

#### è§£æ³•äºŒï¼šä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ O(log(m + n)) ğŸ’ª

```swift
class Solution {
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
       let count1 = nums1.count, count2 = nums2.count
        let totalCount = count1 + count2
        if totalCount % 2 == 1 {
            let mid = totalCount / 2
            return Double(getKthElement(nums1, nums2, mid + 1))
        } else {
            let mid1 = totalCount / 2 - 1, mid2 = totalCount / 2
            return Double(getKthElement(nums1, nums2, mid1 + 1) + getKthElement(nums1, nums2, mid2 + 1)) / 2
        }
    }
    // è·å–ä¸¤ä¸ªæ•°ç»„ä¸­ç¬¬ K å°çš„æ•°
    func getKthElement(_ nums1: [Int], _ nums2: [Int],_ k: Int) -> Int {
        var k = k
        let count1 = nums1.count, count2 = nums2.count
        var index1 = 0, index2 = 0
        
        while true {
            if index1 == count1 {
                return nums2[index2 + k - 1]
            }
            if index2 == count2 {
                return nums1[index1 + k - 1]
            }
            if k == 1 {
                return min(nums1[index1], nums2[index2])
            }
            let half = k / 2
            let newIndex1 = min(index1 + half, count1) - 1
            let newIndex2 = min(index2 + half, count2) - 1
            let pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2]
            if pivot1 <= pivot2 {
                k -= newIndex1 - index1 + 1
                index1 = newIndex1 + 1
            } else {
                k -= newIndex2 - index2 + 1
                index2 = newIndex2 + 1
            }
        }
    }
}
```

### [5. æœ€é•¿å›æ–‡å­ä¸²](https://leetcode-cn.com/problems/longest-palindromic-substring/)

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `s`ï¼Œæ‰¾åˆ° `s` ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚ä½ å¯ä»¥å‡è®¾ `s` çš„æœ€å¤§é•¿åº¦ä¸º 1000ã€‚

#### æš´åŠ›ç®—æ³• 

> Time:O(n^3) Space: O(1)

```swift
func longestPalindrome(_ s: String) -> String {
        // æš´åŠ›ç®—æ³•
        let n = s.count
        guard n >= 2 else { return s }
        
        var maxLength = 1
        var begin = 0
        let chars = Array(s)
        // æšä¸¾æ‰€æœ‰é•¿åº¦ä¸¥æ ¼å¤§äº 1 çš„å­ä¸² chars[i..j]
        for i in 0..<n - 1 {
            for j in i + 1..<n {
                if j - i + 1 > maxLength && validHelper(chars, i, j) {
                    maxLength = j - i + 1
                    begin = i
                }
            }
        }
        return String(chars[begin..<(begin + maxLength)])
}

func validHelper(_ arr: [Character], _ i: Int, _ j: Int) -> Bool {
  var i = i
  var j = j
  while i < j {
    if arr[i] != arr[j] {
      return false
    }
    i += 1
    j -= 1
  }
  return true
}
```

#### åŠ¨æ€è§„åˆ’ 

> Time: O(n^2) space: O(n^2)

```swift
func longestPalindrome(_ s: String) -> String {
        // åŠ¨æ€è§„åˆ’
        // dp(i, j) = s[i] == s[j] && dp(i + 1, j - 1)
        let n = s.count
        guard n >= 2 else {
            return s
        }
        var maxLength = 1
        var begin = 0
        var dp = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)
        // å¯¹è§’çº¿éƒ½ä¸º trueï¼ˆå› ä¸ºå•ä¸ªå­—ç¬¦å¿…å®šä¸ºå›æ–‡åºåˆ—ï¼‰
        for i in 0..<n {
            dp[i][i] = true
        }
        let chars = Array(s)
        for j in 1..<n { // å¯¹è§’çº¿å·²ç»å¤„ç†ï¼Œæ‰€ä»¥åˆ—ä» 1 å¼€å§‹
            for i in 0..<j { // å¯¹è§’çº¿ä»¥ä¸‹ä¸ç”¨ç®¡ï¼Œæ‰€ä»¥åªåˆ° j å°±ç»“æŸäº†
                if chars[i] != chars[j] {
                    dp[i][j] = false
                } else {
                    dp[i][j] = j - i < 3 || dp[i + 1][j - 1] // ç®€åŒ–ä¸º 1 è¡Œï¼Œç­‰åŒäºä¸‹é¢ 5 è¡Œ
//                    if j - 1 - (i + 1) + 1 < 2 { // è¡¨ç¤º j - 1 åˆ° i + 1 ä¹‹é—´æ²¡æœ‰å­—ç¬¦æˆ–åªæœ‰ä¸€ä¸ªå­—ç¬¦ï¼Œåˆ™è‚¯å®šæ˜¯å›æ–‡ä¸²
//                        dp[i][j] = true
//                    } else {
//                        dp[i][j] = dp[i + 1][j - 1] // çŠ¶æ€è½¬ç§»ï¼Œæ›´é‡Œé¢çš„å­ä¸²ä¼šä¼˜å…ˆè®¡ç®—å‡ºå›æ–‡æ€§è´¨
//                    }
                }
                if dp[i][j] && j - i + 1 > maxLength { // å¦‚æœçŠ¶æ€æ­£ç¡®ä¸”é•¿åº¦å¤§äºåŸå…ˆçš„æœ€å¤§é•¿åº¦ï¼Œåˆ™å¯¹ begin å’Œ maxLength è¿›è¡Œæ›´æ–°
                    maxLength = j - i + 1
                    begin = i
                }
            }
        }
        return String(chars[begin..<(begin+maxLength)])
    }
```



### [7. æ•´æ•°åè½¬](https://leetcode-cn.com/problems/reverse-integer/)

ç»™å‡ºä¸€ä¸ª 32 ä½çš„æœ‰ç¬¦å·æ•´æ•°ï¼Œä½ éœ€è¦å°†è¿™ä¸ªæ•´æ•°ä¸­æ¯ä½ä¸Šçš„æ•°å­—è¿›è¡Œåè½¬

```swift
	func reverse(_ x: Int) -> Int {
    var x = x
    var res = 0
    while x != 0 {
      let mod = x % 10 // å¾—å‡ºæœ«å°¾æ•°å­—
      x /= 10 // å‰”é™¤æœ«å°¾
      res = res * 10 + mod // é€†åºæ±‚å’Œ
    }
    return abs(res) > Int32.max ? 0 : res
  }
```



## [8. å­—ç¬¦ä¸²è½¬æ¢æ•´æ•° (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

è¯·ä½ æ¥å®ç°ä¸€ä¸ª atoi å‡½æ•°ï¼Œä½¿å…¶èƒ½å°†å­—ç¬¦ä¸²è½¬æ¢æˆæ•´æ•°ã€‚é¦–å…ˆï¼Œè¯¥å‡½æ•°ä¼šæ ¹æ®éœ€è¦ä¸¢å¼ƒæ— ç”¨çš„å¼€å¤´ç©ºæ ¼å­—ç¬¦ï¼Œç›´åˆ°å¯»æ‰¾åˆ°ç¬¬ä¸€ä¸ªéç©ºæ ¼çš„å­—ç¬¦ä¸ºæ­¢ã€‚æ¥ä¸‹æ¥çš„è½¬åŒ–è§„åˆ™å¦‚ä¸‹ï¼šå¦‚æœç¬¬ä¸€ä¸ªéç©ºå­—ç¬¦ä¸ºæ­£æˆ–è€…è´Ÿå·æ—¶ï¼Œåˆ™å°†è¯¥ç¬¦å·ä¸ä¹‹åé¢å°½å¯èƒ½å¤šçš„è¿ç»­æ•°å­—å­—ç¬¦ç»„åˆèµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªæœ‰ç¬¦å·æ•´æ•°ã€‚
å‡å¦‚ç¬¬ä¸€ä¸ªéç©ºå­—ç¬¦æ˜¯æ•°å­—ï¼Œåˆ™ç›´æ¥å°†å…¶ä¸ä¹‹åè¿ç»­çš„æ•°å­—å­—ç¬¦ç»„åˆèµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªæ•´æ•°ã€‚
è¯¥å­—ç¬¦ä¸²åœ¨æœ‰æ•ˆçš„æ•´æ•°éƒ¨åˆ†ä¹‹åä¹Ÿå¯èƒ½ä¼šå­˜åœ¨å¤šä½™çš„å­—ç¬¦ï¼Œé‚£ä¹ˆè¿™äº›å­—ç¬¦å¯ä»¥è¢«å¿½ç•¥ï¼Œå®ƒä»¬å¯¹å‡½æ•°ä¸åº”è¯¥é€ æˆå½±å“ã€‚
æ³¨æ„ï¼šå‡å¦‚è¯¥å­—ç¬¦ä¸²ä¸­çš„ç¬¬ä¸€ä¸ªéç©ºæ ¼å­—ç¬¦ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆæ•´æ•°å­—ç¬¦ã€å­—ç¬¦ä¸²ä¸ºç©ºæˆ–å­—ç¬¦ä¸²ä»…åŒ…å«ç©ºç™½å­—ç¬¦æ—¶ï¼Œåˆ™ä½ çš„å‡½æ•°ä¸éœ€è¦è¿›è¡Œè½¬æ¢ï¼Œå³æ— æ³•è¿›è¡Œæœ‰æ•ˆè½¬æ¢ã€‚åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œè‹¥å‡½æ•°ä¸èƒ½è¿›è¡Œæœ‰æ•ˆçš„è½¬æ¢æ—¶ï¼Œè¯·è¿”å› 0 ã€‚

```swift
	func myAtoi(_ str: String) -> Int {
        let chars = Array(str)
        let n = chars.count
        var idx = 0
        while idx < n && chars[idx] == " " {
            idx += 1 // å»ç©ºæ ¼
        }
        if idx == n {
            return 0
        }
        // å¤„ç†ç¬¦å·
        var sign = 1
        if chars[idx] == "-" {
            sign = -1
            idx += 1
        } else if chars[idx] == "+" {
            idx += 1
        } else if !(chars[idx].isASCII && chars[idx].isWholeNumber) {
            return 0
        }
        var ans = 0
        while idx < n {
            if !(chars[idx].isASCII && chars[idx].isWholeNumber) {
                break
            }
            let digit = chars[idx].wholeNumberValue!
            if ans > (Int(Int32.max) - digit) / 10 {
                return Int(sign > 0 ? Int32.max : Int32.min)
            }
            ans = ans * 10 + digit
            idx += 1
        }
        return ans * sign
    }
```



### [9. å›æ–‡æ•°](https://leetcode-cn.com/problems/palindrome-number/)

åˆ¤æ–­ä¸€ä¸ªæ•´æ•°æ˜¯å¦æ˜¯å›æ–‡æ•°ã€‚å›æ–‡æ•°æ˜¯æŒ‡æ­£åºï¼ˆä»å·¦å‘å³ï¼‰å’Œå€’åºï¼ˆä»å³å‘å·¦ï¼‰è¯»éƒ½æ˜¯ä¸€æ ·çš„æ•´æ•°ã€‚

```swift
	func isPalindrome(_ x: Int) -> Bool {
        if x < 0 || (x % 10 == 0 && x != 0) {
            return false
        }
        var reverseNumber = 0
        var x = x
        while reverseNumber < x {
            reverseNumber = reverseNumber * 10 + x % 10
            x /= 10
        }
        return reverseNumber == x || x == reverseNumber / 10
    }
```





------

### [88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„](https://leetcode-cn.com/problems/merge-sorted-array/)

ç»™ä½ ä¸¤ä¸ªæœ‰åºæ•´æ•°æ•°ç»„ nums1 å’Œ nums2ï¼Œè¯·ä½ å°† nums2 åˆå¹¶åˆ° nums1 ä¸­ï¼Œä½¿ nums1 æˆä¸ºä¸€ä¸ªæœ‰åºæ•°ç»„ã€‚

è¯´æ˜:

åˆå§‹åŒ– nums1 å’Œ nums2 çš„å…ƒç´ æ•°é‡åˆ†åˆ«ä¸º m å’Œ n ã€‚
ä½ å¯ä»¥å‡è®¾ nums1 æœ‰è¶³å¤Ÿçš„ç©ºé—´ï¼ˆç©ºé—´å¤§å°å¤§äºæˆ–ç­‰äº m + nï¼‰æ¥ä¿å­˜ nums2 ä¸­çš„å…ƒç´ ã€‚

```swift
	func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
        // åŒæŒ‡é’ˆ
        var l1 = m - 1
        var l2 = n - 1
        var l = m + n - 1
        
        while l1 >= 0 && l2 >= 0 {
            if nums1[l1] > nums2[l2] {
                nums1[l] = nums1[l1]
                l1 -= 1
            } else {
                nums1[l] = nums2[l2]
                l2 -= 1
            }
            l -= 1
        }
        if l2 >= 0 {
            nums1.replaceSubrange(0..<l2 + 1, with: nums2[0..<l2 + 1])  // è¿™é‡Œå¯ä»¥æ›¿æ¢ä¸º while å¾ªç¯
            /*
            while l2 >= 0 {
                nums1[l2] = nums2[l2]
                l2 -= 1
            }
             */
        }
    }
```



### [237. åˆ é™¤é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

ç»™å®šä¸€ä¸ª node èŠ‚ç‚¹ï¼Œå°†å…¶åœ¨é“¾è¡¨ä¸­åˆ é™¤ã€‚ï¼ˆæ¯”è¾ƒ trickyï¼Œç›´æ¥æ¢ val å¯è¿˜è¡Œï¼Ÿï¼‰

```swift
class Solution {
    func deleteNode(_ node: ListNode?) {
        guard let next = node?.next else { return }
        node?.val = next.val
        node?.next = next.next
    }
}
```

### [104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

æ±‚äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ï¼Œä¹Ÿå°±æ˜¯æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€è¿œè·¯å¾„çš„èŠ‚ç‚¹æ•°ã€‚

> æ¨èä½¿ç”¨æ·±åº¦ä¼˜å…ˆï¼Œé€’å½’å³å¯å¿«é€Ÿè§£é¢˜ï¼Œå¹¶ä¸”å¤æ‚åº¦å’Œå¹¿åº¦ä¼˜å…ˆç›¸åŒ

```swift
class Solution {
    func maxDepth(_ root: TreeNode?) -> Int {
        guard let root = root else { return  0 }
        return max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
}
```